/// \file SDHCALContentApi.cc
/*
 *
 * SDHCALContentApi.cc source template automatically generated by a class generator
 * Creation date : mar. avr. 28 2015
 *
 * This file is part of SDHCALContent libraries.
 * 
 * SDHCALContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * SDHCALContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with SDHCALContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */


#include "SDHCALApi/SDHCALContentApi.h"

#include "SDHCALObjects/CaloHit.h"
#include "SDHCALObjects/Connector.h"
#include "SDHCALObjects/SDHCALMetaData.h"

#include "Api/PandoraContentApi.h"

sdhcal_content::ClusterFactory SDHCALContentApi::m_clusterFactory;

pandora::StatusCode SDHCALContentApi::AlterMetadata(const pandora::Algorithm &algorithm, const sdhcal_content::CaloHit *const pCaloHit, const SDHCALContentApi::CaloHitMetadata &caloHitMetadata)
{
  // alter pandora calo hit meta data
  const pandora::CaloHit *const pPandoraCaloHit(pCaloHit);
  const PandoraContentApi::CaloHit::Metadata pandoraCaloHitMetadata(caloHitMetadata);

  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::CaloHit::AlterMetadata(algorithm, pPandoraCaloHit, pandoraCaloHitMetadata));

  if(caloHitMetadata.m_surroundingEnergy.IsInitialized())
    SDHCALContentApi::Modifiable(pCaloHit)->m_surroundingEnergy = caloHitMetadata.m_surroundingEnergy.Get();

  if(caloHitMetadata.m_density.IsInitialized())
    SDHCALContentApi::Modifiable(pCaloHit)->m_density = caloHitMetadata.m_density.Get();

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool SDHCALContentApi::IsConnected(const sdhcal_content::CaloHit *const pCaloHit1, const sdhcal_content::CaloHit *const pCaloHit2)
{
  return pCaloHit1->m_pCaloHitMetaData->IsConnected(pCaloHit2);
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool SDHCALContentApi::IsConnected(const sdhcal_content::CaloHit *const pCaloHit1, const sdhcal_content::CaloHit *const pCaloHit2, sdhcal_content::ConnectorDirection direction)
{
  return pCaloHit1->m_pCaloHitMetaData->IsConnected(pCaloHit2, direction);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::FindConnector(const sdhcal_content::CaloHit *const pCaloHit1, const sdhcal_content::CaloHit *const pCaloHit2, const sdhcal_content::Connector *&pConnector)
{
  return pCaloHit1->m_pCaloHitMetaData->FindConnector(pCaloHit2, pConnector);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::FindConnector(const sdhcal_content::CaloHit *const pCaloHit1, const sdhcal_content::CaloHit *const pCaloHit2, sdhcal_content::ConnectorDirection direction,
    const sdhcal_content::Connector *&pConnector)
{
  return pCaloHit1->m_pCaloHitMetaData->FindConnector(pCaloHit2, direction, pConnector);
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool SDHCALContentApi::HasAnyConnection(const sdhcal_content::CaloHit *const pCaloHit)
{
  return pCaloHit->m_pCaloHitMetaData->HasAnyConnection();
}

//------------------------------------------------------------------------------------------------------------------------------------------

const sdhcal_content::ConnectorList &SDHCALContentApi::GetConnectorList(const sdhcal_content::CaloHit *const pCaloHit)
{
  return pCaloHit->m_pCaloHitMetaData->GetConnectorList();
}

//------------------------------------------------------------------------------------------------------------------------------------------

const sdhcal_content::ConnectorList &SDHCALContentApi::GetConnectorList(const sdhcal_content::CaloHit *const pCaloHit, sdhcal_content::ConnectorDirection direction)
{
  return pCaloHit->m_pCaloHitMetaData->GetConnectorList(direction);
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool SDHCALContentApi::IsSeed(const sdhcal_content::CaloHit *const pCaloHit)
{
  return pCaloHit->m_pCaloHitMetaData->IsSeed();
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool SDHCALContentApi::IsLeaf(const sdhcal_content::CaloHit *const pCaloHit)
{
  return pCaloHit->m_pCaloHitMetaData->IsLeaf();
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::Connect(const sdhcal_content::CaloHit *const pCaloHit1, const sdhcal_content::CaloHit *const pCaloHit2, sdhcal_content::ConnectorDirection direction,
    float referenceLength, unsigned int creationStage)
{
  const sdhcal_content::Connector *pConnector = NULL;
  return SDHCALContentApi::Connect(pCaloHit1, pCaloHit2, direction, pConnector, referenceLength, creationStage);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::Connect(const sdhcal_content::CaloHit *const pCaloHit1, const sdhcal_content::CaloHit *const pCaloHit2, sdhcal_content::ConnectorDirection direction,
    const sdhcal_content::Connector *&pConnector, float referenceLength, unsigned int creationStage)
{
  pConnector = NULL;

  sdhcal_content::CaloHit *const pCaloHitFrom = direction == sdhcal_content::BACKWARD_DIRECTION ? SDHCALContentApi::Modifiable(pCaloHit2) : SDHCALContentApi::Modifiable(pCaloHit1);
  sdhcal_content::CaloHit *const pCaloHitTo = direction == sdhcal_content::BACKWARD_DIRECTION ? SDHCALContentApi::Modifiable(pCaloHit1) : SDHCALContentApi::Modifiable(pCaloHit2);

  pConnector = new sdhcal_content::Connector(pCaloHitFrom, pCaloHitTo, referenceLength, creationStage);

  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCaloHitFrom->m_pCaloHitMetaData->AddConnector(pConnector, sdhcal_content::FORWARD_DIRECTION));
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCaloHitTo->m_pCaloHitMetaData->AddConnector(pConnector, sdhcal_content::BACKWARD_DIRECTION));

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::RemoveConnectionBetween(const sdhcal_content::CaloHit *const pCaloHit1, const sdhcal_content::CaloHit *const pCaloHit2)
{
  if(NULL == pCaloHit1 || NULL == pCaloHit2)
    return pandora::STATUS_CODE_INVALID_PARAMETER;

  const sdhcal_content::Connector *pConnector = NULL;
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, pCaloHit1->m_pCaloHitMetaData->FindConnector(pCaloHit2, pConnector));

  return SDHCALContentApi::RemoveAndDeleteConnector(pConnector);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::RemoveConnector(const sdhcal_content::Connector *const pConnector)
{
  if(NULL == pConnector)
    return pandora::STATUS_CODE_INVALID_PARAMETER;

  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, SDHCALContentApi::Modifiable(pConnector->GetFrom())->m_pCaloHitMetaData->RemoveConnector(pConnector));
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, SDHCALContentApi::Modifiable(pConnector->GetTo())->m_pCaloHitMetaData->RemoveConnector(pConnector));

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::RemoveAndDeleteConnector(const sdhcal_content::Connector *const pConnector)
{
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, SDHCALContentApi::RemoveConnector(pConnector));
  delete SDHCALContentApi::Modifiable(pConnector);

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::RemoveAndDeleteAllConnections(const sdhcal_content::CaloHit *const pCaloHit)
{
  sdhcal_content::ConnectorList backwardConnectorList(pCaloHit->m_pCaloHitMetaData->GetConnectorList(sdhcal_content::BACKWARD_DIRECTION));
  sdhcal_content::ConnectorList forwardConnectorList(pCaloHit->m_pCaloHitMetaData->GetConnectorList(sdhcal_content::FORWARD_DIRECTION));

  for(sdhcal_content::ConnectorList::const_iterator iter = backwardConnectorList.begin(), endIter = backwardConnectorList.end() ;
      endIter != iter ; ++iter)
  {
    const sdhcal_content::Connector *const pConnector = *iter;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, SDHCALContentApi::RemoveAndDeleteConnector(pConnector));
  }

  for(sdhcal_content::ConnectorList::const_iterator iter = forwardConnectorList.begin(), endIter = forwardConnectorList.end() ;
      endIter != iter ; ++iter)
  {
    const sdhcal_content::Connector *const pConnector = *iter;
    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, SDHCALContentApi::RemoveAndDeleteConnector(pConnector));
  }

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::Tag(const sdhcal_content::CaloHit *const pCaloHit, sdhcal_content::HitTag tag, bool value)
{
  SDHCALContentApi::Modifiable(pCaloHit)->m_hitTagMap.set(tag, value);
  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

bool SDHCALContentApi::IsTagged(const sdhcal_content::CaloHit *const pCaloHit, sdhcal_content::HitTag tag)
{
  return pCaloHit->m_hitTagMap.test(tag);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::ResetTags(const sdhcal_content::CaloHit *const pCaloHit)
{
  if(NULL == pCaloHit)
    return pandora::STATUS_CODE_INVALID_PARAMETER;

  SDHCALContentApi::Modifiable(pCaloHit)->m_hitTagMap.reset();

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::InitializeReclustering(const pandora::Algorithm &algorithm, const pandora::TrackList &inputTrackList,
    const pandora::ClusterList &inputClusterList, std::string &originalClustersListName)
{
  // Initialize re-clustering within pandora
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::InitializeReclustering(algorithm, inputTrackList, inputClusterList, originalClustersListName));

  // Current calo hit list here is the one for re-clustering
  // Get it, save and create new meta data for each
  const pandora::CaloHitList *pCaloHitList = NULL;
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(algorithm, pCaloHitList));

  for(pandora::CaloHitList::const_iterator iter = pCaloHitList->begin(), endIter = pCaloHitList->end() ;
      endIter != iter ; ++iter)
  {
    const sdhcal_content::CaloHit *const pCaloHit = dynamic_cast<const sdhcal_content::CaloHit *const>(*iter);

    if(NULL == pCaloHit)
      return pandora::STATUS_CODE_FAILURE;

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, SDHCALContentApi::Modifiable(pCaloHit)->SaveReclusterMetaData(originalClustersListName));
  }

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::RunReclusteringAlgorithm(const pandora::Algorithm &algorithm, const std::string &clusteringAlgorithmName,
    const pandora::ClusterList *&pNewClusterList, std::string &newClusterListName)
{
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::RunClusteringAlgorithm(algorithm, clusteringAlgorithmName, pNewClusterList, newClusterListName));

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::PostRunReclusteringAlgorithm(const pandora::Algorithm &algorithm, const std::string &clusterListName)
{
  // Get the current re-clustering calo hit list
  // Save meta data for each calo hit
  const pandora::CaloHitList *pCaloHitList = NULL;
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(algorithm, pCaloHitList));

  for(pandora::CaloHitList::const_iterator iter = pCaloHitList->begin(), endIter = pCaloHitList->end() ;
      endIter != iter ; ++iter)
  {
    const sdhcal_content::CaloHit *const pCaloHit = dynamic_cast<const sdhcal_content::CaloHit *const>(*iter);

    if(NULL == pCaloHit)
      return pandora::STATUS_CODE_FAILURE;

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, SDHCALContentApi::Modifiable(pCaloHit)->SaveReclusterMetaData(clusterListName));
  }

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::EndReclustering(const pandora::Algorithm &algorithm, const std::string &selectedClusterListName)
{
  const pandora::CaloHitList *pCaloHitList = NULL;
  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::GetCurrentList(algorithm, pCaloHitList));

  for(pandora::CaloHitList::const_iterator iter = pCaloHitList->begin(), endIter = pCaloHitList->end() ;
      endIter != iter ; ++iter)
  {
    const sdhcal_content::CaloHit *const pCaloHit = dynamic_cast<const sdhcal_content::CaloHit *const>(*iter);

    if(NULL == pCaloHit)
      return pandora::STATUS_CODE_FAILURE;

    PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, SDHCALContentApi::Modifiable(pCaloHit)->EndReclustering(selectedClusterListName));
  }

  PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::EndReclustering(algorithm, selectedClusterListName));

  return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::Create(const pandora::Algorithm &algorithm, 
		PandoraContentApi::Cluster::Parameters clusterParameters, const pandora::Cluster *&pCluster)
{
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(algorithm, clusterParameters, pCluster));

	pandora::CaloHitList& caloHitList(clusterParameters.m_caloHitList);

	for(auto& caloHit : caloHitList)
	{
        const sdhcal_content::CaloHit *const pSDHCALCaloHit = dynamic_cast<const sdhcal_content::CaloHit *const>(caloHit);
		Modifiable(pSDHCALCaloHit)->SetMother(pCluster);
	}

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------
pandora::StatusCode SDHCALContentApi::CreateSDHCALCluster(const pandora::Algorithm &algorithm, 
		PandoraContentApi::Cluster::Parameters clusterParameters, const pandora::Cluster *&pCluster)
{
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::Cluster::Create(algorithm, clusterParameters, pCluster, m_clusterFactory));

	pandora::CaloHitList& caloHitList(clusterParameters.m_caloHitList);

	for(auto& caloHit : caloHitList)
	{
        const sdhcal_content::CaloHit *const pSDHCALCaloHit = dynamic_cast<const sdhcal_content::CaloHit *const>(caloHit);
		Modifiable(pSDHCALCaloHit)->SetMother(pCluster);
	}

    return pandora::STATUS_CODE_SUCCESS;

}
            
//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::RemoveFromCluster(const pandora::Algorithm &algorithm, 
		const pandora::Cluster *const pCluster, const pandora::CaloHit *const pCaloHit)
{
    const sdhcal_content::CaloHit *const pSDHCALCaloHit = dynamic_cast<const sdhcal_content::CaloHit *const>(pCaloHit);
	Modifiable(pSDHCALCaloHit)->SetMother(nullptr);

	return PandoraContentApi::RemoveFromCluster(algorithm, pCluster, pCaloHit);
}

//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::MergeAndDeleteClusters(const pandora::Algorithm &algorithm, 
		const pandora::Cluster *const pClusterToEnlarge, const pandora::Cluster *pClusterToDelete)
{
	pandora::CaloHitList origClusterHits;
    pClusterToEnlarge->GetOrderedCaloHitList().FillCaloHitList(origClusterHits);
	pandora::CaloHitList origIsoCaloHitList = pClusterToEnlarge->GetIsolatedCaloHitList();
	origClusterHits.insert(origClusterHits.begin(), origIsoCaloHitList.begin(), origIsoCaloHitList.end());

	pandora::CaloHitList clusterHits;
    pClusterToDelete->GetOrderedCaloHitList().FillCaloHitList(clusterHits);
	pandora::CaloHitList isoCaloHitList = pClusterToDelete->GetIsolatedCaloHitList();
	clusterHits.insert(clusterHits.begin(), isoCaloHitList.begin(), isoCaloHitList.end());

	origClusterHits.insert(origClusterHits.begin(), clusterHits.begin(), clusterHits.end());

	for(auto& caloHit : origClusterHits)
	{
        const sdhcal_content::CaloHit *const pSDHCALCaloHit = dynamic_cast<const sdhcal_content::CaloHit *const>(caloHit);
		Modifiable(pSDHCALCaloHit)->SetMother(pClusterToEnlarge);
	}

	return PandoraContentApi::MergeAndDeleteClusters(algorithm, pClusterToEnlarge, pClusterToDelete);
}
        
//------------------------------------------------------------------------------------------------------------------------------------------

pandora::StatusCode SDHCALContentApi::AddToCluster(const pandora::Algorithm &algorithm, 
		const pandora::Cluster *const pCluster, const pandora::CaloHitList *const pCaloHitList)
{
	PANDORA_RETURN_RESULT_IF(pandora::STATUS_CODE_SUCCESS, !=, PandoraContentApi::AddToCluster(algorithm, pCluster, pCaloHitList));

	for(auto& caloHit : *pCaloHitList)
	{
        const sdhcal_content::CaloHit *const pSDHCALCaloHit = dynamic_cast<const sdhcal_content::CaloHit *const>(caloHit);
		Modifiable(pSDHCALCaloHit)->SetMother(pCluster);
	}

    return pandora::STATUS_CODE_SUCCESS;
}

//------------------------------------------------------------------------------------------------------------------------------------------

template <typename T>
T *SDHCALContentApi::Modifiable(const T *const pT)
{
  return const_cast<T*>(pT);
}

//------------------------------------------------------------------------------------------------------------------------------------------


template sdhcal_content::SDHCALCluster *SDHCALContentApi::Modifiable(const sdhcal_content::SDHCALCluster *const);

template sdhcal_content::CaloHit   *SDHCALContentApi::Modifiable(const sdhcal_content::CaloHit   *const);
template sdhcal_content::Connector *SDHCALContentApi::Modifiable(const sdhcal_content::Connector *const);

