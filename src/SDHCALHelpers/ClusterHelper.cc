/// \file ClusterHelper.cc
/*
 *
 * ClusterHelper.cc source template automatically generated by a class generator
 * Creation date : ven. avr. 10 2015
 * Updated november 2023 by Tanguy Pasquier
 *
 * This file is part of SDHCALContent libraries.
 * 
 * SDHCALContent is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * based upon these libraries are permitted. Any copy of these libraries
 * must include this copyright notice.
 * 
 * SDHCALContent is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with SDHCALContent.  If not, see <http://www.gnu.org/licenses/>.
 * 
 * @author Remi Ete
 * @copyright CNRS , IPNL
 */

#include "Pandora/AlgorithmHeaders.h"

#include "SDHCALHelpers/ClusterHelper.h"
#include "SDHCALApi/SDHCALContentApi.h"
//#include "SDHCALHelpers/CaloHitHelper.h"
//#include "SDHCALHelpers/GeometryHelper.h"
//#include "SDHCALHelpers/ReclusterHelper.h"
//#include "SDHCALHelpers/CaloHitNeighborSearchHelper.h"

#include "TMatrixT.h"
#include "TMatrixDEigen.h"
#include "TVectorD.h"

#include "TVector3.h"
#include "TRotation.h"
#include "TH2F.h"

namespace sdhcal_content
{

  pandora::StatusCode ClusterHelper::GetCentroid(const pandora::Cluster *const pCluster, pandora::CartesianVector &centroid)
  {
#if 0
    const pandora::OrderedCaloHitList &orderedCaloHitList(pCluster->GetOrderedCaloHitList());

    for(pandora::OrderedCaloHitList::const_iterator iter = orderedCaloHitList.begin(), endIter = orderedCaloHitList.end() ;
        endIter != iter ; ++iter)
    {
      centroid += pCluster->GetCentroid(iter->first);
    }

    centroid *= 1.f/(orderedCaloHitList.size());
#endif

    pandora::CaloHitList clusterCaloHitList;
    pCluster->GetOrderedCaloHitList().FillCaloHitList(clusterCaloHitList);

	const pandora::CaloHitList& isolatedCaloHitList = pCluster->GetIsolatedCaloHitList();
	clusterCaloHitList.insert(clusterCaloHitList.begin(), isolatedCaloHitList.begin(), isolatedCaloHitList.end());

	//unsigned int nHits = 0;

	pandora::CartesianVector cluCentroid(0., 0., 0.);
	pandora::CartesianVector cluCentroidWithConnector(0., 0., 0.);

  for(auto caloHit : clusterCaloHitList)
	{
    const pandora::CaloHit *const pCaloHit(caloHit); //works  
		//const sdhcal_content::CaloHit *const pCaloHit(dynamic_cast<const sdhcal_content::CaloHit *const>(caloHit)); //returns nullptr
		cluCentroid += pCaloHit->GetPositionVector();
  //Not truly coherent for now
		/* if(SDHCALContentApi::HasAnyConnection(pCaloHit))
		{
			cluCentroidWithConnector += pCaloHit->GetPositionVector();
			++nHits;
		} */
	}

	// if(nHits>=2)
	// {
	// 	centroid = cluCentroidWithConnector * (1./nHits);
	// }
	// else
	// {
		centroid = cluCentroid * (1./clusterCaloHitList.size());
	//}

    return pandora::STATUS_CODE_SUCCESS;
  }

  bool ClusterHelper::CanMergeCluster(const pandora::Pandora &pandora, const pandora::Cluster *const pCluster, 
		  const float minMipFraction, const float maxAllHitsFitRms)
  {
      if (0 == pCluster->GetNCaloHits())
          return false;
  
      if (!(pCluster->PassPhotonId(pandora)))
          return true;
  
      if (pCluster->GetMipFraction() - minMipFraction > std::numeric_limits<float>::epsilon())
          return true;
  
      return (pCluster->GetFitToAllHitsResult().IsFitSuccessful() && (pCluster->GetFitToAllHitsResult().GetRms() < maxAllHitsFitRms));
  }

  //------------------------------------------------------------------------------------------------------------------------------------------

} 
